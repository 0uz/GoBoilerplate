---
description: Go net/http clean architecture patterns and dependency rules
alwaysApply: true
---

# Go Clean Architecture with net/http

## Layer Structure

```
internal/
├── domain/          # Entities, value objects, repository interfaces
├── application/     # Use cases, services, DTOs
└── adapters/
    ├── api/         # HTTP handlers, middleware
    └── repo/        # Repository implementations
```

## Dependency Rule

Dependencies flow **inward only**:

```
adapters → application → domain
```

- `domain/` imports nothing from internal
- `application/` imports only from `domain/`
- `adapters/` imports from `application/` and `domain/`

## Domain Layer

Define interfaces and entities without external dependencies:

```go
// ❌ BAD - domain importing adapter
package user
import "myapp/internal/adapters/repo/postgres"

// ✅ GOOD - domain defines interface
package user
type Repository interface {
    FindByID(ctx context.Context, id string) (*User, error)
    Save(ctx context.Context, user *User) error
}
```

## Application Layer

Services orchestrate domain logic with DTOs for input/output:

```go
// ❌ BAD - returning domain entity directly to handler
func (s *UserService) GetUser(id string) (*domain.User, error)

// ✅ GOOD - use DTOs for application boundaries
func (s *UserService) GetUser(ctx context.Context, id string) (*dto.UserResponse, error) {
    user, err := s.repo.FindByID(ctx, id)
    if err != nil {
        return nil, err
    }
    return dto.NewUserResponse(user), nil
}
```

## HTTP Handlers (Adapters)

Handlers should be thin - delegate to application services:

```go
// ❌ BAD - business logic in handler
func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    // validation, business rules, DB queries here...
}

// ✅ GOOD - handler delegates to service
func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    id := r.PathValue("id")
    
    user, err := h.userService.GetUser(r.Context(), id)
    if err != nil {
        response.Error(w, err)
        return
    }
    
    response.JSON(w, http.StatusOK, user)
}
```

## Repository Implementation

Implement domain interfaces in adapters:

```go
// internal/adapters/repo/postgres/user/user_repository.go
type UserRepository struct {
    db *gorm.DB
}

// Implements domain.UserRepository
func (r *UserRepository) FindByID(ctx context.Context, id string) (*domain.User, error) {
    var user domain.User
    if err := r.db.WithContext(ctx).First(&user, "id = ?", id).Error; err != nil {
        return nil, err
    }
    return &user, nil
}
```

## Dependency Injection

Wire dependencies at composition root (`cmd/main.go`):

```go
// ✅ GOOD - compose at main
func main() {
    db := postgres.NewDatabase(cfg)
    userRepo := userrepo.NewUserRepository(db)
    userService := usersvc.NewUserService(userRepo)
    userHandler := api.NewUserHandler(userService)
}
```

## Error Handling

Use domain errors, map to HTTP in adapters:

```go
// domain/errors.go
var ErrNotFound = errors.New("not found")

// adapters/api - map domain errors to HTTP
switch {
case errors.Is(err, domain.ErrNotFound):
    response.Error(w, http.StatusNotFound, "resource not found")
case errors.Is(err, domain.ErrValidation):
    response.Error(w, http.StatusBadRequest, err.Error())
default:
    response.Error(w, http.StatusInternalServerError, "internal error")
}
```

## Comments

No unnecessary or redundant comments. Add comments only when:

- Explaining complex logic or algorithms
- Clarifying non-obvious variable or function purposes
- Providing context for external APIs, integrations, or edge cases

```go
// ❌ BAD - obvious, redundant
func (s *UserService) GetUser(ctx context.Context, id string) (*dto.UserResponse, error) {
    // get user from repository
    user, err := s.repo.FindByID(ctx, id)
    // check error
    if err != nil {
        // return error
        return nil, err
    }
    // return user response
    return dto.NewUserResponse(user), nil
}

// ✅ GOOD - only comment non-obvious logic
func (s *UserService) GetUser(ctx context.Context, id string) (*dto.UserResponse, error) {
    user, err := s.repo.FindByID(ctx, id)
    if err != nil {
        return nil, err
    }
    return dto.NewUserResponse(user), nil
}

// ✅ GOOD - comment explains why, not what
func (s *TokenService) Generate(userID string) (string, error) {
    // Use 32 bytes for HMAC-SHA256 compliance
    secret := make([]byte, 32)
    // ...
}
```

## Logging

No debug logs unless explicitly required. Use structured logging at appropriate levels:

```go
// ❌ BAD - debug noise
func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    log.Debug("entering GetUser handler")
    id := r.PathValue("id")
    log.Debug("got id: " + id)
    
    user, err := h.userService.GetUser(r.Context(), id)
    log.Debug("service returned")
    // ...
}

// ✅ GOOD - log only meaningful events
func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    id := r.PathValue("id")
    
    user, err := h.userService.GetUser(r.Context(), id)
    if err != nil {
        log.Error("failed to get user", "id", id, "error", err)
        response.Error(w, err)
        return
    }
    
    response.JSON(w, http.StatusOK, user)
}
```

**Log levels:**
- `Error` - failures requiring attention
- `Warn` - recoverable issues, degraded functionality
- `Info` - significant business events (user created, payment processed)
- `Debug` - only for active troubleshooting, remove after
